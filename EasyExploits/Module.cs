using System;
using System.IO;
using System.IO.Pipes;
using System.Net;
using System.Net.Security;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Windows.Forms;
using Microsoft.Win32;

namespace EasyExploits
{
	// Token: 0x02000002 RID: 2
	public class Module
	{
        private static bool AlwaysGoodCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors policyErrors)
        {
            return true;
        }
        private static bool CheckLastestDll(RegistryKey registryKey)
		{
            ServicePointManager.ServerCertificateValidationCallback += new RemoteCertificateValidationCallback(AlwaysGoodCertificate);
            ServicePointManager.Expect100Continue = true;
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
            string[] array = wc.DownloadString("https://raw.githubusercontent.com/GreenMs02/Update/master/Module.txt").Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
			if (!(array[2] == "true"))
			{
				return false;
			}
			if (Directory.Exists(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Roblox\\Versions\\" + array[3]))
			{
				registryKey.SetValue("Ver", array[3]);
				return true;
			}
			return false;
		}

		// Token: 0x06000002 RID: 2 RVA: 0x000020BC File Offset: 0x000002BC
		public static bool CheckDllUpdate()
		{
            ServicePointManager.ServerCertificateValidationCallback += new RemoteCertificateValidationCallback(AlwaysGoodCertificate);
            ServicePointManager.Expect100Continue = true;
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
            string[] array = wc.DownloadString("https://raw.githubusercontent.com/GreenMs02/Update/master/Module.txt").Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
			RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\\\CoCO", true);
			if (registryKey == null)
			{
				registryKey = Registry.CurrentUser.CreateSubKey("SOFTWARE\\\\CoCO");
				registryKey.SetValue("Ver", "0");
			}
			else
			{
				if (registryKey.GetValue("Ver").ToString() != array[0])
				{
					registryKey.SetValue("Ver", array[0]);
					return true;
				}
				if (registryKey.GetValue("Ver").ToString() != array[3] && CheckLastestDll(registryKey))
				{
					return true;
				}
			}
			return !File.Exists("EasyExploitsDLL.dll");
		}

		// Token: 0x06000003 RID: 3 RVA: 0x0000217C File Offset: 0x0000037C
		public static bool DownloadDLL()
		{
            ServicePointManager.ServerCertificateValidationCallback += new RemoteCertificateValidationCallback(AlwaysGoodCertificate);
            ServicePointManager.Expect100Continue = true;
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
            RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\\\CoCO", true);
			string[] array = wc.DownloadString("https://raw.githubusercontent.com/GreenMs02/Update/master/Module.txt").Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
			if (registryKey.GetValue("Ver").ToString() == array[3] && CheckLastestDll(registryKey))
			{
				wc.DownloadFile(array[4], "EasyExploitsDLL.dll");
			}
			else
			{
				wc.DownloadFile(array[1], "EasyExploitsDLL.dll");
			}
			return File.Exists("EasyExploitsDLL.dll");
		}

		// Token: 0x06000004 RID: 4 RVA: 0x00002210 File Offset: 0x00000410
		public static void ExecuteScript(string Script)
		{
			if (namedPipeExist("ocybedam"))
			{
				using (NamedPipeClientStream namedPipeClientStream = new NamedPipeClientStream(".", "ocybedam", PipeDirection.Out))
				{
					namedPipeClientStream.Connect();
					using (StreamWriter streamWriter = new StreamWriter(namedPipeClientStream, Encoding.Default, 999999))
					{
						streamWriter.Write(Script);
						streamWriter.Dispose();
					}
					namedPipeClientStream.Dispose();
				}
			}
			else
			{
				MessageBox.Show("Please attach!", "NamedPipeDoesntExist", MessageBoxButtons.OK, MessageBoxIcon.Hand);
			}
		}
		public static bool namedPipeExist(string pipeName)
		{
			bool result;
			try
			{
				if (!Module.WaitNamedPipe(Path.GetFullPath(string.Format("\\\\.\\pipe\\{0}", pipeName)), 0))
				{
					int lastWin32Error = Marshal.GetLastWin32Error();
					if (lastWin32Error == 0)
					{
						result = false;
						return result;
					}
					if (lastWin32Error == 2)
					{
						result = false;
						return result;
					}
				}
				result = true;
			}
			catch (Exception)
			{
				result = false;
			}
			return result;
		}
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern bool WaitNamedPipe(string name, int timeout);
		private static WebClient wc = new WebClient();
	}
}
